import 'dart:convert' as dart_convert;

import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';
import 'package:generic_shop_app_architecture/arch.dart';
import 'package:shared_preferences/shared_preferences.dart' as shared_preferences;
import 'package:sembast/sembast.dart' as sembast;
import 'package:sembast_web/sembast_web.dart' as sembast_web;
import 'package:sembast/sembast_io.dart' as sembast_io;
import 'package:sembast/utils/database_utils.dart' as sembast_utils;

part '../../i18n/service_cache_i18n.dart';
part 'service_cache_entry.dart';
part 'service_cache_value.dart';

/// Cache data manager, providing permanent / device storage solutions to app clients.
///
class GsaServiceCache extends GsaService {
  GsaServiceCache._();

  static final _instance = GsaServiceCache._();

  /// Globally-accesible class instance.
  ///
  static GsaServiceCache get instance => _instance() as GsaServiceCache;

  @override
  bool get critical => true;

  @override
  bool get manualInit => true;

  /// Cache manager version specifier.
  ///
  /// Updating this value will invoke the migration process on the app startup.
  ///
  static const int _version = 0;

  /// Whether the implementation is relying on
  /// [sembast_web](https://pub.dev/packages/sembast_web)
  /// as opposed to the [https://pub.dev/packages/shared_preferences] package.
  ///
  /// The shared_preferences implementation might run into
  /// [QuotaExceededError](https://developer.mozilla.org/en-US/docs/Web/API/QuotaExceededError),
  /// which is why a database integration is preferred.
  ///
  bool database = kIsWeb || kIsWasm;

  /// Entrypoint to the methods and properties provided by the shared_preferences package.
  ///
  shared_preferences.SharedPreferencesWithCache? _sharedPreferences;

  /// A class to manage database storage for cache services.
  ///
  sembast.Database? _db;

  /// A pointer to a database store.
  ///
  sembast.StoreRef? _dbStorage;

  /// Runtime collection of values retrieved from the secure storage.
  ///
  Map<int, Map<String, String>>? _dbStorageEntries;

  /// Retrieves a value from [_dbStorageEntries] denoted with [key].
  ///
  /// As the database records keys with integer values,
  /// the [key] value is denoted as a [Map] object key representing the stored value.
  ///
  String? _getDbStorageValue(
    String cacheId,
  ) {
    return _dbStorageEntries?.entries
        .firstWhereOrNull(
          (entry) {
            return entry.value.keys.first == cacheId;
          },
        )
        ?.value
        .values
        .first;
  }

  /// Records a [value] with specified [cacheId] to the local database.
  ///
  /// The value will also be recorded to the [_dbStorageEntries] collection.
  ///
  Future<void> _setDbStorageValue({
    required String cacheId,
    required String value,
  }) async {
    if (_db == null) {
      throw Exception(
        'No database available for setting values.',
      );
    }
    final key = await _dbStorage?.generateIntKey(
      _db!,
    );
    if (key == null) {
      throw Exception(
        'No key generated by sembast for $cacheId.',
      );
    }
    await _removeDbStorageValue(
      cacheId,
      localOnly: true,
    );
    final entry = {cacheId: value};
    await _dbStorage?.record(key).put(
          _db!,
          dart_convert.jsonEncode(entry),
        );
    _dbStorageEntries?[key] = entry;
  }

  /// Removes a cache entry value from the local database and from the [_dbStorageEntries] collection.
  ///
  Future<void> _removeDbStorageValue(
    String cacheId, {
    bool localOnly = false,
  }) async {
    if (_db == null) {
      throw Exception(
        'No database available for setting values.',
      );
    }
    final storageValue = _dbStorageEntries?.entries.firstWhereOrNull(
      (entry) {
        return entry.value.keys.first == cacheId;
      },
    );
    if (storageValue != null) {
      if (!localOnly) {
        await _dbStorage
            ?.record(
              storageValue.key,
            )
            .delete(
              _db!,
            );
      }
      _dbStorageEntries?.remove(
        storageValue.key,
      );
    }
  }

  /// Prefix assigned to each of the cached item entries.
  ///
  String? cacheIdPrefix;

  /// Initialises the [_sharedPreferences] property and handle data cache versions.
  ///
  /// The method must be manually invoked at app startup,
  /// as [GsaData] and [GsaService] implementations rely on the cache service.
  ///
  @override
  Future<void> init() async {
    await super.init();
    const timeoutDuration = Duration(seconds: 10);
    const timeoutMessage = 'Failed to initialise cache service within alloted timeframe.';
    if (database) {
      _dbStorage = sembast.intMapStoreFactory.store();
      _db = await sembast_web.databaseFactoryWeb.openDatabase('gsaCache').timeout(
        timeoutDuration,
        onTimeout: () {
          throw Exception(timeoutMessage);
        },
      );
      final entries = await _dbStorage!.find(_db!);
      _dbStorageEntries = {};
      for (final entry in entries) {
        if (entry.key != null && entry.value != null) {
          _dbStorageEntries![entry.key as int] = Map<String, String>.from(
            dart_convert.jsonDecode(
              entry.value.toString(),
            ),
          );
        }
      }
    } else {
      _sharedPreferences = await shared_preferences.SharedPreferencesWithCache.create(
        cacheOptions: shared_preferences.SharedPreferencesWithCacheOptions(),
      ).timeout(
        timeoutDuration,
        onTimeout: () {
          throw Exception(timeoutMessage);
        },
      );
    }
  }

  /// Collection of cache value entries specified for the app instance.
  ///
  /// May be edited during the runtime to ensure correct data propagation and handling.
  ///
  final _cacheEntries = <GsaServiceCacheValue>[
    ...GsaServiceCacheEntry.values,
  ];

  /// Registers client cache entries for cookie value adjustment.
  ///
  void registerCacheEntries(
    List<GsaServiceCacheValue> values,
  ) {
    _cacheEntries.addAll(values);
  }

  /// Event triggered on user cookie acknowledgement.
  ///
  Future<void> onCookieConsentAcknowledged() async {
    final version = GsaServiceCacheEntry.version.value as int?;

    /// If the cached version is different than the current [_version],
    /// handle logic for updating cached values.
    if (_version != version) {
      if (version == null) {
        /// If the cached [version] argument is `null`,
        /// the user hasn't previously acknowledged cache service consent.
        ///
        /// Once the user has given their consent,
        /// default values defined for [GsaServiceCacheEntry] objects are recorded to device storage.
        ///
        for (final cacheId in GsaServiceCacheEntry.values) {
          if (cacheId.defaultValue != null) {
            try {
              cacheId.setValue(cacheId.defaultValue);
            } catch (e) {
              GsaServiceLogging.instance.logError('Error setting default cache value: $e');
            }
          }
        }
      } else {
        switch (version) {
          /// Here we can add logic for handling cached values if is a newer version of cache manager.
          case _version:
            // Version is up-to-date.
            break;
          default:
            throw '${GsaServiceCacheI18N.invalidVersionErrorMessage.value.display}: $version';
        }
      }
    }
    // Clear cookies according to user consent status.
    for (final cacheEntry in _cacheEntries) {
      if (cacheEntry.isFunctionalCookie && GsaServiceConsent.instance.consentStatus.functionalCookies() != true) {
        await cacheEntry.removeValue();
      }
    }
    GsaServiceBookmarks.instance.controllerUpdate.add(null);
  }

  /// Persistent cache data; shouldn't be deleted.
  ///
  final persistent = <GsaServiceCacheEntry>{
    GsaServiceCacheEntry.version,
    GsaServiceCacheEntry.cookieConsentMandatory,
    GsaServiceCacheEntry.cookieConsentFunctional,
    GsaServiceCacheEntry.cookieConsentMarketing,
    GsaServiceCacheEntry.cookieConsentStatistical,
  };

  /// Collection of cached value keys stored to the user device.
  ///
  Set<String>? get cachedKeys {
    if (database) {
      return _dbStorageEntries?.keys.map(
        (intKey) {
          return intKey.toString();
        },
      ).toSet();
    } else {
      return _sharedPreferences?.keys;
    }
  }

  /// Removes all cache data from the device storage,
  /// except for the keys noted under the [persistent] list.
  ///
  Future<void> clearData({
    bool clearPersistent = false,
  }) async {
    for (var key in cachedKeys ?? <String>[]) {
      if (clearPersistent ||
          persistent
              .where(
                (cacheId) => cacheId.name == key,
              )
              .isEmpty) {
        if (database) {
          if (_db != null && int.tryParse(key) != null) {
            await _dbStorage
                ?.record(
                  int.parse(key),
                )
                .delete(_db!);
          }
        } else {
          await _sharedPreferences?.remove(key);
        }
      }
    }
  }

  /// Returns a value associated with the specified [key].
  ///
  dynamic valueWithKey(String key) {
    if (database) {
      // TODO?
      return null;
    } else {
      return _sharedPreferences?.get(key);
    }
  }
}
